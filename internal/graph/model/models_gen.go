// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/ClusterCockpit/cc-backend/pkg/schema"
)

type Count struct {
	Name  string `json:"name"`
	Count int    `json:"count"`
}

type EnergyFootprintValue struct {
	Hardware string  `json:"hardware"`
	Metric   string  `json:"metric"`
	Value    float64 `json:"value"`
}

type FloatRange struct {
	From float64 `json:"from"`
	To   float64 `json:"to"`
}

type FootprintValue struct {
	Name  string  `json:"name"`
	Stat  string  `json:"stat"`
	Value float64 `json:"value"`
}

type Footprints struct {
	TimeWeights *TimeWeights        `json:"timeWeights"`
	Metrics     []*MetricFootprints `json:"metrics"`
}

type HistoPoint struct {
	Count int `json:"count"`
	Value int `json:"value"`
}

type IntRangeOutput struct {
	From int `json:"from"`
	To   int `json:"to"`
}

type JobFilter struct {
	Tags            []string          `json:"tags,omitempty"`
	JobID           *StringInput      `json:"jobId,omitempty"`
	ArrayJobID      *int              `json:"arrayJobId,omitempty"`
	User            *StringInput      `json:"user,omitempty"`
	Project         *StringInput      `json:"project,omitempty"`
	JobName         *StringInput      `json:"jobName,omitempty"`
	Cluster         *StringInput      `json:"cluster,omitempty"`
	Partition       *StringInput      `json:"partition,omitempty"`
	Duration        *schema.IntRange  `json:"duration,omitempty"`
	Energy          *FloatRange       `json:"energy,omitempty"`
	MinRunningFor   *int              `json:"minRunningFor,omitempty"`
	NumNodes        *schema.IntRange  `json:"numNodes,omitempty"`
	NumAccelerators *schema.IntRange  `json:"numAccelerators,omitempty"`
	NumHWThreads    *schema.IntRange  `json:"numHWThreads,omitempty"`
	StartTime       *schema.TimeRange `json:"startTime,omitempty"`
	State           []schema.JobState `json:"state,omitempty"`
	MetricStats     []*MetricStatItem `json:"metricStats,omitempty"`
	Exclusive       *int              `json:"exclusive,omitempty"`
	Node            *StringInput      `json:"node,omitempty"`
}

type JobLink struct {
	ID    string `json:"id"`
	JobID int    `json:"jobId"`
}

type JobLinkResultList struct {
	ListQuery *string    `json:"listQuery,omitempty"`
	Items     []*JobLink `json:"items"`
	Count     *int       `json:"count,omitempty"`
}

type JobMetricWithName struct {
	Name   string             `json:"name"`
	Scope  schema.MetricScope `json:"scope"`
	Metric *schema.JobMetric  `json:"metric"`
}

type JobResultList struct {
	Items       []*schema.Job `json:"items"`
	Offset      *int          `json:"offset,omitempty"`
	Limit       *int          `json:"limit,omitempty"`
	Count       *int          `json:"count,omitempty"`
	HasNextPage *bool         `json:"hasNextPage,omitempty"`
}

type JobStats struct {
	Name  string                   `json:"name"`
	Stats *schema.MetricStatistics `json:"stats"`
}

type JobStatsWithScope struct {
	Name  string             `json:"name"`
	Scope schema.MetricScope `json:"scope"`
	Stats []*ScopedStats     `json:"stats"`
}

type JobsStatistics struct {
	ID             string               `json:"id"`
	Name           string               `json:"name"`
	TotalJobs      int                  `json:"totalJobs"`
	RunningJobs    int                  `json:"runningJobs"`
	ShortJobs      int                  `json:"shortJobs"`
	TotalWalltime  int                  `json:"totalWalltime"`
	TotalNodes     int                  `json:"totalNodes"`
	TotalNodeHours int                  `json:"totalNodeHours"`
	TotalCores     int                  `json:"totalCores"`
	TotalCoreHours int                  `json:"totalCoreHours"`
	TotalAccs      int                  `json:"totalAccs"`
	TotalAccHours  int                  `json:"totalAccHours"`
	HistDuration   []*HistoPoint        `json:"histDuration"`
	HistNumNodes   []*HistoPoint        `json:"histNumNodes"`
	HistNumCores   []*HistoPoint        `json:"histNumCores"`
	HistNumAccs    []*HistoPoint        `json:"histNumAccs"`
	HistMetrics    []*MetricHistoPoints `json:"histMetrics"`
}

type MetricFootprints struct {
	Metric string         `json:"metric"`
	Data   []schema.Float `json:"data"`
}

type MetricHistoPoint struct {
	Bin   *int `json:"bin,omitempty"`
	Count int  `json:"count"`
	Min   *int `json:"min,omitempty"`
	Max   *int `json:"max,omitempty"`
}

type MetricHistoPoints struct {
	Metric string              `json:"metric"`
	Unit   string              `json:"unit"`
	Stat   *string             `json:"stat,omitempty"`
	Data   []*MetricHistoPoint `json:"data,omitempty"`
}

type MetricStatItem struct {
	MetricName string      `json:"metricName"`
	Range      *FloatRange `json:"range"`
}

type Mutation struct {
}

type NodeMetrics struct {
	Host       string               `json:"host"`
	SubCluster string               `json:"subCluster"`
	Metrics    []*JobMetricWithName `json:"metrics"`
}

type NodesResultList struct {
	Items       []*NodeMetrics `json:"items"`
	Offset      *int           `json:"offset,omitempty"`
	Limit       *int           `json:"limit,omitempty"`
	Count       *int           `json:"count,omitempty"`
	TotalNodes  *int           `json:"totalNodes,omitempty"`
	HasNextPage *bool          `json:"hasNextPage,omitempty"`
}

type OrderByInput struct {
	Field string            `json:"field"`
	Type  string            `json:"type"`
	Order SortDirectionEnum `json:"order"`
}

type PageRequest struct {
	ItemsPerPage int `json:"itemsPerPage"`
	Page         int `json:"page"`
}

type ScopedStats struct {
	Hostname string                   `json:"hostname"`
	ID       *string                  `json:"id,omitempty"`
	Data     *schema.MetricStatistics `json:"data"`
}

type StringInput struct {
	Eq         *string  `json:"eq,omitempty"`
	Neq        *string  `json:"neq,omitempty"`
	Contains   *string  `json:"contains,omitempty"`
	StartsWith *string  `json:"startsWith,omitempty"`
	EndsWith   *string  `json:"endsWith,omitempty"`
	In         []string `json:"in,omitempty"`
}

type TimeRangeOutput struct {
	Range *string   `json:"range,omitempty"`
	From  time.Time `json:"from"`
	To    time.Time `json:"to"`
}

type TimeWeights struct {
	NodeHours []schema.Float `json:"nodeHours"`
	AccHours  []schema.Float `json:"accHours"`
	CoreHours []schema.Float `json:"coreHours"`
}

type User struct {
	Username string `json:"username"`
	Name     string `json:"name"`
	Email    string `json:"email"`
}

type Aggregate string

const (
	AggregateUser    Aggregate = "USER"
	AggregateProject Aggregate = "PROJECT"
	AggregateCluster Aggregate = "CLUSTER"
)

var AllAggregate = []Aggregate{
	AggregateUser,
	AggregateProject,
	AggregateCluster,
}

func (e Aggregate) IsValid() bool {
	switch e {
	case AggregateUser, AggregateProject, AggregateCluster:
		return true
	}
	return false
}

func (e Aggregate) String() string {
	return string(e)
}

func (e *Aggregate) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Aggregate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Aggregate", str)
	}
	return nil
}

func (e Aggregate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortByAggregate string

const (
	SortByAggregateTotalwalltime  SortByAggregate = "TOTALWALLTIME"
	SortByAggregateTotaljobs      SortByAggregate = "TOTALJOBS"
	SortByAggregateTotalnodes     SortByAggregate = "TOTALNODES"
	SortByAggregateTotalnodehours SortByAggregate = "TOTALNODEHOURS"
	SortByAggregateTotalcores     SortByAggregate = "TOTALCORES"
	SortByAggregateTotalcorehours SortByAggregate = "TOTALCOREHOURS"
	SortByAggregateTotalaccs      SortByAggregate = "TOTALACCS"
	SortByAggregateTotalacchours  SortByAggregate = "TOTALACCHOURS"
)

var AllSortByAggregate = []SortByAggregate{
	SortByAggregateTotalwalltime,
	SortByAggregateTotaljobs,
	SortByAggregateTotalnodes,
	SortByAggregateTotalnodehours,
	SortByAggregateTotalcores,
	SortByAggregateTotalcorehours,
	SortByAggregateTotalaccs,
	SortByAggregateTotalacchours,
}

func (e SortByAggregate) IsValid() bool {
	switch e {
	case SortByAggregateTotalwalltime, SortByAggregateTotaljobs, SortByAggregateTotalnodes, SortByAggregateTotalnodehours, SortByAggregateTotalcores, SortByAggregateTotalcorehours, SortByAggregateTotalaccs, SortByAggregateTotalacchours:
		return true
	}
	return false
}

func (e SortByAggregate) String() string {
	return string(e)
}

func (e *SortByAggregate) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortByAggregate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortByAggregate", str)
	}
	return nil
}

func (e SortByAggregate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumDesc SortDirectionEnum = "DESC"
	SortDirectionEnumAsc  SortDirectionEnum = "ASC"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumDesc,
	SortDirectionEnumAsc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumDesc, SortDirectionEnumAsc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
